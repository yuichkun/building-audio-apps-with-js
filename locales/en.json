{
  "title": "Building Production-Ready Audio Apps with JavaScript",
  "slide2": {
    "heading": "Making Sound on Web"
  },
  "slide3": {
    "heading": "2 ways to make sound on web"
  },
  "slide4": {
    "heading": "Which one to choose? 🤔"
  },
  "slide5": {
    "when": "when...",
    "list1": "you just want to play a sound file",
    "list2": "you don't need fine-grained control over loading",
    "list3": "you only need to play it as-is",
    "or": "or"
  },
  "slide9": {
    "heading": "...not happy?"
  },
  "slide10": {
    "heading": "Welcome to the world of Web Audio API 🤝",
    "survey": "Quick survey: Who have ever used Web Audio API before?"
  },
  "slide11": {
    "list1": "High-level JavaScript API for audio processing",
    "list2": "Node-based audio routing graph architecture",
    "list3": "Runs on a separate high-priority audio thread",
    "list4": "Built-in audio nodes for common tasks (gain, filters, oscillators, etc.)"
  },
  "slide12": {
    "heading": "Simple playback using Web Audio API",
    "subtitle": "with low-pass filter"
  },
  "slide14": {
    "heading": "👁️ When built-in nodes don't satisfy your needs...",
    "rescue": "to the rescue! 🧑‍🚒"
  },
  "slide15": {
    "list1": "Enables custom audio processing on the audio rendering thread",
    "list2": "Runs on audio thread (not main thread) = no glitches",
    "list3": "Two-part architecture: Processor + Node",
    "list4": "Must load processor module via addModule()",
    "list5": "Use MessagePort for bidirectional communication"
  },
  "slide16": {
    "heading": "Code Example: Building a GainProcessor",
    "basedOn": "Based on example from"
  }
}
