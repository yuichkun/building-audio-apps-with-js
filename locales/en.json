{
  "title": "Building Production-Ready Audio Apps with JavaScript",
  "slide2": {
    "heading": "Making Sound on Web"
  },
  "slide3": {
    "heading": "2 ways to make sound on web"
  },
  "slide4": {
    "heading": "Which one to choose? ü§î"
  },
  "slide5": {
    "when": "when...",
    "list1": "you just want to play a sound file",
    "list2": "you don't need fine-grained control over loading",
    "list3": "you only need to play it as-is",
    "or": "or"
  },
  "slide9": {
    "heading": "...not happy?"
  },
  "slide10": {
    "heading": "Welcome to the world of Web Audio API ü§ù",
    "survey": "Quick survey: Who have ever used Web Audio API before?"
  },
  "slide11": {
    "list1": "High-level JavaScript API for audio processing",
    "list2": "Node-based audio routing graph architecture",
    "list3": "Runs on a separate high-priority audio thread",
    "list4": "Built-in audio nodes for common tasks (gain, filters, oscillators, etc.)"
  },
  "slide12": {
    "heading": "Simple playback using Web Audio API",
    "subtitle": "with low-pass filter"
  },
  "slide14": {
    "heading": "üëÅÔ∏è When built-in nodes don't satisfy your needs...",
    "rescue": "to the rescue! üßë‚Äçüöí"
  },
  "slide15": {
    "list1": "Enables custom audio processing on the audio rendering thread",
    "list2": "Runs on audio thread (not main thread) = no glitches",
    "list3": "Two-part architecture: Processor + Node",
    "list4": "Must load processor module via addModule()",
    "list5": "Use MessagePort for bidirectional communication"
  },
  "slide16": {
    "heading": "Code Example: Building a GainProcessor",
    "basedOn": "Based on example from"
  },
  "slide17": {
    "mainThread": "Main Thread",
    "yourApp": "your app",
    "audioThread": "Audio Thread",
    "processor": "processor"
  },
  "slide18": {
    "heading": "Fun Example: Simple Reverb"
  },
  "slide20": {
    "mainThread": "Main Thread",
    "audioThread": "Audio Thread"
  },
  "slide21": {
    "heading": "‚ö†Ô∏è Critical: The 3ms Rule",
    "list1": "At 44.1kHz,",
    "list1b": "is called",
    "list1c": "~344 times per second",
    "list1d": "(128 frames each)",
    "list2": "Each call has only",
    "list2b": "~3ms",
    "list2c": "to complete",
    "list3": "Exceeding this budget causes",
    "list3b": "audio glitches",
    "source": "Source:"
  },
  "slide22": {
    "heading": "Live Demo: Exceeding the 3ms Budget",
    "description": "Use the slider to add artificial processing delay. Watch (and hear!) what happens when you go beyond 3ms."
  },
  "slide24": {
    "heading": "Need more speed?",
    "answer": "...WebAssembly has you covered üöÄ"
  },
  "slide25": {
    "heading": "Leveraging WebAssembly for AudioWorklet",
    "whyWasm": "Why WASM? ü§î",
    "list1": "Near-native performance for complex audio processing",
    "list2": "Reuse existing audio codebases in the browser",
    "popularOptions": "Popular options:",
    "juceDesc": "Professional audio framework (used by Synthesizer V)",
    "rnboDesc": "Export Max/MSP patches to Web Audio"
  },
  "slide26": {
    "heading": "What is JUCE? üéµ",
    "list1": "C++ framework for building audio applications and plugins",
    "list2": "Used by Adobe, Steinberg, Universal Audio, Waves, and more",
    "list3": "Cross-platform: Windows, macOS, Linux, iOS, Android",
    "list4": "Supports all major plugin formats (VST, AU, AAX)"
  },
  "slide27": {
    "heading": "JUCE + Emscripten in Action",
    "description": "project enables JUCE applications to run in browsers via WebAssembly.",
    "tryDemo": "Try the live demo"
  },
  "slide28": {
    "heading": "What is Max? üé®",
    "list1": "Visual programming environment for audio and multimedia (formerly Max/MSP)",
    "list2": "Developed by Cycling '74",
    "list3": "Connect objects with virtual cables instead of writing code",
    "list4": "Build custom synthesizers, effects, and interactive installations",
    "list5": "RNBO exports Max patches to Web Audio (via WASM), VST, and more"
  }
}
