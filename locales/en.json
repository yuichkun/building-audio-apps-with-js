{
  "title": "Building Production-Ready Audio Apps with JavaScript",
  "slide2": {
    "heading": "Making Sound on Web"
  },
  "slide3": {
    "heading": "2 ways to make sound on web"
  },
  "slide4": {
    "heading": "Which one to choose? ü§î"
  },
  "slide5": {
    "when": "when...",
    "list1": "you just want to play a sound file",
    "list2": "you don't need fine-grained control over loading",
    "list3": "you only need to play it as-is",
    "or": "or"
  },
  "slide9": {
    "heading": "...not happy?"
  },
  "slide10": {
    "heading": "Welcome to the world of Web Audio API ü§ù",
    "survey": "Quick survey: Who have ever used Web Audio API before?"
  },
  "slide11": {
    "list1": "High-level JavaScript API for audio processing",
    "list2": "Node-based audio routing graph architecture",
    "list3": "Runs on a separate high-priority audio thread",
    "list4": "Built-in audio nodes for common tasks (gain, filters, oscillators, etc.)"
  },
  "slide12": {
    "heading": "Simple playback using Web Audio API",
    "subtitle": "with low-pass filter"
  },
  "slide14": {
    "heading": "üëÅÔ∏è When built-in nodes don't satisfy your needs...",
    "rescue": "to the rescue! üßë‚Äçüöí"
  },
  "slide15": {
    "list1": "Enables custom audio processing on the audio rendering thread",
    "list2": "Runs on audio thread (not main thread) = no glitches",
    "list3": "Two-part architecture: Processor + Node",
    "list4": "Must load processor module via addModule()",
    "list5": "Use MessagePort for bidirectional communication"
  },
  "slide16": {
    "heading": "Code Example: Building a GainProcessor",
    "basedOn": "Based on example from"
  },
  "slide17": {
    "mainThread": "Main Thread",
    "yourApp": "your app",
    "audioThread": "Audio Thread",
    "processor": "processor"
  },
  "slide18": {
    "heading": "Fun Example: Simple Reverb"
  },
  "slide20": {
    "mainThread": "Main Thread",
    "audioThread": "Audio Thread"
  },
  "slide21": {
    "heading": "‚ö†Ô∏è Critical: The 3ms Rule",
    "list1": "At 44.1kHz,",
    "list1b": "is called",
    "list1c": "~344 times per second",
    "list1d": "(128 frames each)",
    "list2": "Each call has only",
    "list2b": "~3ms",
    "list2c": "to complete",
    "list3": "Exceeding this budget causes",
    "list3b": "audio glitches",
    "source": "Source:"
  },
  "slide22": {
    "heading": "Live Demo: Exceeding the 3ms Budget",
    "description": "Use the slider to add artificial processing delay. Watch (and hear!) what happens when you go beyond 3ms."
  },
  "slide24": {
    "heading": "Need more speed?",
    "answer": "...WebAssembly has you covered üöÄ"
  },
  "slide25": {
    "heading": "Leveraging WebAssembly for AudioWorklet",
    "whyWasm": "Why WASM? ü§î",
    "list1": "Near-native performance for complex audio processing",
    "list2": "Reuse existing audio codebases in the browser",
    "popularOptions": "Popular options:",
    "juceDesc": "Professional audio framework (used by Synthesizer V)",
    "rnboDesc": "Export Max/MSP patches to Web Audio"
  },
  "slide26": {
    "heading": "What is JUCE? üéµ",
    "list1": "C++ framework for building audio applications and plugins",
    "list2": "Used by Adobe, Steinberg, Universal Audio, Waves, and more",
    "list3": "Cross-platform: Windows, macOS, Linux, iOS, Android",
    "list4": "Supports all major plugin formats (VST, AU, AAX)"
  },
  "slide27": {
    "heading": "JUCE + Emscripten in Action",
    "description": "project enables JUCE applications to run in browsers via WebAssembly.",
    "tryDemo": "Try the live demo"
  },
  "slide28": {
    "heading": "What is Max? üé®",
    "list1": "Visual programming environment for audio and multimedia (formerly Max/MSP)",
    "list2": "Developed by Cycling '74",
    "list3": "Connect objects with virtual cables instead of writing code",
    "list4": "Build custom synthesizers, effects, and interactive installations",
    "list5": "RNBO exports Max patches to Web Audio (via WASM), VST, and more"
  },
  "slide29": {
    "heading": "Made with RNBO",
    "collaboration": "Collaboration with",
    "soundDesigner": "sound designer at teamLAB",
    "tryDemo": "Try the demo"
  },
  "slide30": {
    "howWeBuilt": "How we built it:",
    "list1": "Kentaro designed the DSP (audio processing) in Max",
    "list2": "RNBO compiled the Max patch into WebAssembly",
    "list3": "I built the UI with Svelte and integrated the WASM module",
    "list4": "Connected UI controls to audio parameters via RNBO API",
    "list5": "WASM delivers near-native performance, much faster than JavaScript"
  },
  "slide31": {
    "heading": "Experimental: WebGPU-Accelerated Audio",
    "description": "WebGPU brings GPU compute to the browser - perfect for heavy DSP"
  },
  "slide32": {
    "heading": "Convolution Reverb with WebGPU",
    "convolution": "Convolution",
    "convolutionDesc": "multiply input signal with impulse response (IR)",
    "cpuImpl": "CPU Implementation",
    "cpuImplDesc": "~3.9 billion operations/sec for 2s reverb - too slow for real-time",
    "gpuImpl": "GPU Implementation",
    "gpuImplDesc": "Parallel compute shader - fast enough!"
  },
  "slide33": {
    "heading": "That's pretty much it"
  },
  "slide34": {
    "heading": "Who am I?",
    "list1": "Studied composition at Tokyo University of the Arts",
    "list2": "Founder and creative lead at",
    "weDeliver": "We deliver:",
    "video": "Video production",
    "graphics": "3D graphics",
    "music": "Tailored music and sound design",
    "webApps": "Web apps, games, and other digital experiences"
  },
  "slide35": {
    "heading": "Lastly..."
  },
  "slide36": {
    "heading": "Special Thanks",
    "anthony": "a friend from bouldering üßó and creator of",
    "powered": "This presentation is powered by",
    "slidevDesc": "the only tool that makes sounds and i18n in slides possible!"
  }
}
