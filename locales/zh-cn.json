{
  "title": "使用JavaScript构建生产级音频应用",
  "slide2": {
    "heading": "在Web上发声"
  },
  "slide3": {
    "heading": "在Web上发声的2种方法"
  },
  "slide4": {
    "heading": "选择哪一个？🤔"
  },
  "slide5": {
    "when": "当...",
    "list1": "你只想播放一个音频文件",
    "list2": "不需要精细控制加载过程",
    "list3": "只需要原样播放",
    "or": "或者"
  },
  "slide9": {
    "heading": "...不满意？"
  },
  "slide10": {
    "heading": "欢迎来到Web Audio API的世界 🤝",
    "survey": "快速调查：谁用过Web Audio API？"
  },
  "slide11": {
    "list1": "用于音频处理的高级JavaScript API",
    "list2": "基于节点的音频路由图架构",
    "list3": "在独立的高优先级音频线程上运行",
    "list4": "内置音频节点用于常见任务（增益、滤波器、振荡器等）"
  },
  "slide12": {
    "heading": "使用Web Audio API进行简单播放",
    "subtitle": "带低通滤波器"
  },
  "slide14": {
    "heading": "👁️ 当内置节点无法满足需求时...",
    "rescue": "来拯救你！🧑‍🚒"
  },
  "slide15": {
    "list1": "在音频渲染线程上启用自定义音频处理",
    "list2": "在音频线程上运行（而非主线程）= 无卡顿",
    "list3": "双部分架构：Processor + Node",
    "list4": "必须通过addModule()加载处理器模块",
    "list5": "使用MessagePort进行双向通信"
  },
  "slide16": {
    "heading": "代码示例：构建GainProcessor",
    "basedOn": "基于示例来自"
  },
  "slide17": {
    "mainThread": "主线程",
    "yourApp": "你的应用",
    "audioThread": "音频线程",
    "processor": "处理器"
  },
  "slide18": {
    "heading": "有趣的示例：简单混响"
  },
  "slide20": {
    "mainThread": "主线程",
    "audioThread": "音频线程"
  },
  "slide21": {
    "heading": "⚠️ 关键：3ms规则",
    "list1": "在44.1kHz下，",
    "list1b": "每秒被调用",
    "list1c": "约344次",
    "list1d": "（每次128帧）",
    "list2": "每次调用只有",
    "list2b": "约3ms",
    "list2c": "来完成",
    "list3": "超过这个限制会导致",
    "list3b": "音频故障",
    "source": "来源："
  },
  "slide22": {
    "heading": "现场演示：超过3ms限制",
    "description": "使用滑块添加人工处理延迟。看看（并听听！）当超过3ms时会发生什么。"
  },
  "slide24": {
    "heading": "需要更快的速度？",
    "answer": "...WebAssembly帮你搞定 🚀"
  },
  "slide25": {
    "heading": "在AudioWorklet中使用WebAssembly",
    "whyWasm": "为什么用WASM？🤔",
    "list1": "复杂音频处理接近原生性能",
    "list2": "在浏览器中复用现有音频代码库",
    "popularOptions": "流行选择：",
    "juceDesc": "专业音频框架（Synthesizer V使用）",
    "rnboDesc": "将Max/MSP patch导出到Web Audio"
  },
  "slide26": {
    "heading": "什么是JUCE？🎵",
    "list1": "用于构建音频应用和插件的C++框架",
    "list2": "被Adobe、Steinberg、Universal Audio、Waves等使用",
    "list3": "跨平台：Windows、macOS、Linux、iOS、Android",
    "list4": "支持所有主要插件格式（VST、AU、AAX）"
  },
  "slide27": {
    "heading": "JUCE + Emscripten实战",
    "description": "项目使JUCE应用能够通过WebAssembly在浏览器中运行。",
    "tryDemo": "试试现场演示"
  },
  "slide28": {
    "heading": "什么是Max？🎨",
    "list1": "音频和多媒体的可视化编程环境（原Max/MSP）",
    "list2": "由Cycling '74开发",
    "list3": "用虚拟连线连接对象而非编写代码",
    "list4": "构建自定义合成器、效果器和交互式装置",
    "list5": "RNBO将Max patch导出到Web Audio（通过WASM）、VST等"
  },
  "slide29": {
    "heading": "使用RNBO制作",
    "collaboration": "合作伙伴",
    "soundDesigner": "teamLAB的声音设计师",
    "tryDemo": "试试演示"
  },
  "slide30": {
    "howWeBuilt": "我们如何构建：",
    "list1": "Kentaro在Max中设计DSP（音频处理）",
    "list2": "RNBO将Max patch编译成WebAssembly",
    "list3": "我用Svelte构建UI并集成WASM模块",
    "list4": "通过RNBO API连接UI控件到音频参数",
    "list5": "WASM提供接近原生的性能，比JavaScript快得多"
  },
  "slide31": {
    "heading": "实验性：WebGPU加速音频",
    "description": "WebGPU将GPU计算带到浏览器 - 完美适用于重型DSP"
  },
  "slide32": {
    "heading": "使用WebGPU的卷积混响",
    "convolution": "卷积",
    "convolutionDesc": "将输入信号与脉冲响应（IR）相乘",
    "cpuImpl": "CPU实现",
    "cpuImplDesc": "2秒混响约需39亿次运算/秒 - 实时处理太慢",
    "gpuImpl": "GPU实现",
    "gpuImplDesc": "并行计算着色器 - 足够快！"
  },
  "slide33": {
    "heading": "基本就这些了"
  },
  "slide34": {
    "heading": "我是谁？",
    "list1": "毕业于东京艺术大学作曲专业",
    "list2": "创立并领导",
    "weDeliver": "我们提供：",
    "video": "视频制作",
    "graphics": "3D图形",
    "music": "定制音乐和声音设计",
    "webApps": "Web应用、游戏和其他数字体验"
  },
  "slide35": {
    "heading": "最后..."
  },
  "slide36": {
    "heading": "特别感谢",
    "anthony": "来自攀岩的朋友🧗和创作者",
    "powered": "本演示由",
    "slidevDesc": "提供支持 - 唯一能在幻灯片中实现声音和i18n的工具！"
  }
}
